\subsection{Create a new group}\label{sec:implAppNewGroup}
\fig{New group creation flow chart}{appNewGroup}{1.0}{flowCharts/appNewGroup}

Point \ref{req:createGroups} in the requirement specification (appendix \ref{appendix:requirements}) states that one functionality of the application is to create new groups.
When a new group is being created a set of machines should be selectable and different \acrshort{rssi} values mapped to it.
\Cref{fig:appNewGroup} show the flow chart for the creation of a new group.


\subsubsection{Get machines}\label{sec:implAppNewGroupGetMachines}
To be able to choose machines for a new group they first need to be grabbed from an Azure Cosmos database container \cite{IntroductionAzureCosmos}.
The server is taking care of the database handling, which means the application will get the machines from the server with a HTTPs GET request \cite{GETHTTPMDN}.
The API endpoint that is being called is \textit{.../api/machines/all}.
In the application these request is handled with the iOS API \textit{ResourceUrl} \cite{ResourceURLAppleDeveloper}.

\bigskip

On a successful request all machines are loaded into the application.
These machines is then being presented to the user in a list.
The entries in the list is selectable via a touch action, where the selected machines is mapped to the group.
One machine can be used in multiple groups, so the machine ID's is stored in the group.


\subsubsection{Set group name}\label{sec:implAppNewGroupSetName}
For a group to be easier identifiable by a user, a name is set for it.
In the application a text field is filled with the name and then being sent to the server with the rest of the data.


\subsubsection{Map position}\label{sec:implAppNewGroupMapPos}
A group is the part of the system that is being identified as a position in the undefined space and need position fingerprints tied to it.
Nearby \acrshort{ble} iBeacon signals is picked up in the application with the iOS API \textit{CoreLocation} \cite{CoreLocationApple}.

\bigskip

Since the fingerprints that being used by the server are based on three \acrshort{rssi} values, a criterion is set where at least three iBeacons must be in range to be able to map a new position to the group.
If this condition is not met a warning modal is being showed to the user and the data will not be collected.
When the condition is met the nearby iBeacons is collected and the data is being cleaned.
This because the only important value from the iBeacons is their \acrshort{rssi} and minor values.
\Cref{listing:beaconFingerprint} present an example of the formatted iBeacon data.

\fileListing{Formatted iBeacon fingerprint}{beaconFingerprint}{json}{fingerprint.json}

The position mapping is being done manually within the application's user interface.
When a new position is being mapped the cleaned and collected iBeacons data presented in \Cref{listing:beaconFingerprint} is inserted in a 2D array.
In \Cref{listing:groupFingerprints} an example of this 2D array with different iBeacon values is being presented.
\fileListing{A set of collected fingerprints for a group}{groupFingerprints}{json}{groupFingerprints.json}

\subsubsection{Send data to server}\label{sec:implAppnewGroupSend}
When a name is set, machines selected and iBeacons data mapped the group is ready and can be sent to the server as a \acrfull{json} object \cite{IntroducingJSON}.
This is done against the server API endpoint \textit{.../api/group/create} with a HTTPs POST request \cite{POSTHTTPMDN}, where the iOS API \textit{ResourceUrl} \cite{ResourceURLAppleDeveloper} takes care of the request in the application.
Appendix \ref{appendix:newGroupData} presents an example on a full data example of a new group.
